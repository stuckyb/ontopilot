# Copyright (C) 2017 Brian J. Stucky
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Provides high-level management of the imports and ontology build process by
# providing a framework for implementing discrete build targets.  Each build
# target is a concrete subclass of the abstract base classes BuildTarget or
# BuildTargetWithConfig (itself a subclass of BuildTarget), both of which are
# defined in this module.  Targets can be linked together in dependency
# relationships, and build products from dependencies are (optionally) passed
# up the dependency chain to their dependent targets so that high-level build
# targets can directly use the results of low-level build targets.
#

# Python imports.
import abc
import os
from ontoconfig import OntoConfig

# Java imports.


class BuildTarget:
    """
    An abstract base class for all concrete build target classes.
    """
    def __init__(self):
        # This is an abstract base class.
        __metaclass__ = abc.ABCMeta

        # A list of references to the build targets on which this build target
        # depends.
        self.dependencies = []

        # A dictionary to accumulate the build products generated by the build
        # targets on which this target depends.
        self.products = {}

        # Define default error messages for directory creation errors.
        self.bad_dirpath_msg = (
            'A file with the same name as the build target folder, "{0}", '
            'already exists.  Please delete, move, or rename the conflicting '
            'file before continuing.'
        )
        self.bad_dirperms_msg = (
            'The build target folder, "{0}", could not be created.  Please '
            'make sure that you have permission to create new files and '
            'directories in the project location.'
        )

    def _makeDirs(self, dirpath, bad_dirpath_msg='', bad_dirperms_msg=''):
        """
        Attempts to create one or more directories in a path string.  If a
        non-directory file system object with same name already exists, or if
        directory creation fails for some other reason, an exception will be
        thrown.

        dirpath (str): The directory path to create.
        bad_dirpath_msg (str, optional): A custom exception message for
            conflicting path errors.
        bad_dirperms_msg (str, optional): A custom exception message for
            directory creation failure errors.
        """
        if bad_dirpath_msg == '':
            bad_dirpath_msg = self.bad_dirpath_msg
        if bad_dirperms_msg == '':
            bad_dirperms_msg = self.bad_dirperms_msg

        if os.path.exists(dirpath):
            if not(os.path.isdir(dirpath)):
                raise RuntimeError(bad_dirpath_msg.format(dirpath))

        if not(os.path.exists(dirpath)):
            try:
                os.makedirs(dirpath)
            except OSError:
                raise RuntimeError(bad_dirperms_msg.format(dirpath))

    def addDependency(self, target):
        """
        Adds a dependency for this build target.
        """
        self.dependencies.append(target)

    def isBuildRequired(self):
        """
        Determines if the build task needs to be run.  Inspects the state of
        all dependencies as well as this build target.  If any dependencies
        require a build, than this method will automatically return True.
        """
        for dependency in self.dependencies:
            if dependency.isBuildRequired():
                return True

        return self._isBuildRequired()

    def run(self):
        """
        Runs this build task.  All dependencies are processed first.  If the
        build task fails, an appropriate exception should be thrown, and
        exceptions should be allowed to "bubble up" through the dependency
        chain so they can be properly handled by external client code.
        """
        # Invalidate any previous build products.
        self.products.clear()

        dependencies_run = False
        for dependency in self.dependencies:
            results = {}
            if dependency.isBuildRequired():
                dependencies_run = True
                results = dependency.run()

            # Merge the results with the products dictionary, making sure we
            # don't have any duplicate keys.
            for key in results:
                if key not in self.products:
                    self.products[key] = results[key]
                else:
                    raise RuntimeError(
                        'Unable to merge product returned from build target \
{0} into the build products set for build target {1} because of a duplicate \
product name key: "{2}".'.format(
                            dependency.__class__.__name__, self.__class__.__name__, key
                        )
                    )

        # Run the build task for this target.  If we ran any dependencies, we
        # should always run this build task even if the local
        # _isBuildRequired() returns False.
        if self._isBuildRequired() or dependencies_run:
            results = self._run()
            if results == None:
                results = {}
        else:
            results = {}

        # Merge the results of this build target with the products accumulated
        # from lower-level build targets, again making sure we don't have any
        # duplicate keys.
        for key in results:
            if key not in self.products:
                self.products[key] = results[key]
            else:
                raise RuntimeError(
                    'A build product from build target {0} could not be \
merged into the build products set because it uses a product name key that \
duplicates one of its dependency\'s product name keys: "{1}".'.format(
                        self.__class__.__name__, key
                    )
                )

        return self.products
    
    def getBuildNotRequiredMsg(self):
        """
        Returns a string with a target-appropriate message to indicate that
        running the build process is not required.  This can be overridden by
        child classes to provide helpful information for user interfaces.
        """
        return ''

    @abc.abstractmethod
    def _isBuildRequired(self):
        """
        This method must be implemented by child classes.  It should return
        True if a build is required, False otherwise.
        """
        pass

    @abc.abstractmethod
    def _run(self):
        """
        Runs the build task for this particular build target.  This method must
        be implemented by child classes.  When this method is invoked, all
        build targets on which this target depends will have already been run,
        and the results will be in the dictionary self.products.  This method
        should return a dictionary (which may be empty) of build products.
        Alternatively, the method can return None (or have no return statement)
        if no build products need to be passed up the dependency chain.
        """
        return {}


class BuildTargetWithConfig(BuildTarget):
    """
    An abstract base class for build targets that require an instance of a
    project configuration file.  An OntoConfig instance can either be passed to
    the constructor, or the constructor will attempt to instantiate a new
    OntoConfig instance.
    """
    def __init__(self, args, config=None):
        """
        If config is None, then this constructor will attempt to instantiate an
        OntoConfig instance from the value of the 'config_file' member of args.
        If config is not None, then args will not be used.

        args: A "struct" of configuration options (typically, parsed
            command-line arguments).  The only required member is
            'config_file', which should provide the path to a configuration
            file (although this is only used if the config argument is None).
        config (optional): An OntoConfig instance.
        """
        BuildTarget.__init__(self)

        if config == None:
            try:
                self.config = OntoConfig(args.config_file)
            except IOError as err:
                raise RuntimeError(
                    'Unable to load the project configuration file.  Please '
                    'make sure the configuration file exists and that the '
                    'path ("{0}") is correct.  Use the "-c" '
                    '(or "--config_file") option to specify a different '
                    'configuration file or path.'.format(args.config_file)
                )
        else:
            self.config = config

